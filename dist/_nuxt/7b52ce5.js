(window.webpackJsonp=window.webpackJsonp||[]).push([[6,7,8],{282:function(t,n,r){"use strict";r.r(n);n.default="\nattribute vec2 a_position;\nattribute float a_size;\nattribute vec4 a_color;\n\nuniform float u_ratio;\nuniform float u_scale;\nuniform mat3 u_matrix;\n\nvarying vec4 v_color;\nvarying float v_border;\n\nconst float bias = 255.0 / 254.0;\n\nvoid main() {\n  gl_Position = vec4(\n    (u_matrix * vec3(a_position, 1)).xy,\n    0,\n    1\n  );\n\n  // Multiply the point size twice:\n  //  - x SCALING_RATIO to correct the canvas scaling\n  //  - x 2 to correct the formulae\n  gl_PointSize = a_size * u_ratio * u_scale * 2.0;\n\n  v_border = (1.0 / u_ratio) * (0.5 / a_size);\n\n  // Extract the color:\n  v_color = a_color;\n  v_color.a *= bias;\n}\n"},283:function(t,n,r){"use strict";r.r(n);n.default="\nprecision mediump float;\n\nvarying vec4 v_color;\nvarying float v_border;\n\nconst float radius = 0.5;\nconst float halfRadius = 0.35;\n\nvoid main(void) {\n  vec4 transparent = vec4(0.0, 0.0, 0.0, 0.0);\n  vec4 white = vec4(1.0, 1.0, 1.0, 1.0);\n  vec4 blue = vec4(0.125,0.506,0.886, 1.0);\n  float distToCenter = length(gl_PointCoord - vec2(0.5, 0.5));\n\n  float t = 0.0;\n  if (distToCenter < halfRadius - v_border)\n    gl_FragColor = white;\n  else if (distToCenter < halfRadius)\n    gl_FragColor = mix(v_color, blue, (halfRadius - distToCenter) / v_border);\n  else if (distToCenter < radius - v_border)\n    gl_FragColor = v_color;\n  else if (distToCenter < radius)\n    gl_FragColor = mix(transparent, v_color, (radius - distToCenter) / v_border);\n  else\n    gl_FragColor = transparent;\n}\n"},288:function(t,n,r){"use strict";r.r(n),r.d(n,"default",(function(){return y}));r(11),r(289);var o=r(132),e=r(133),c=r(293),l=r(294),f=r(290),v=r(280),d=(r(281),r(284)),_=(r(285),r(282)),h=r(283);function m(t){var n=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(t){return!1}}();return function(){var r,o=Object(f.a)(t);if(n){var e=Object(f.a)(this).constructor;r=Reflect.construct(o,arguments,e)}else r=o.apply(this,arguments);return Object(l.a)(this,r)}}var y=function(t){Object(c.a)(r,t);var n=m(r);function r(t){var e;return Object(o.a)(this,r),(e=n.call(this,t,_.default,h.default,1,4)).bind(),e}return Object(e.a)(r,[{key:"process",value:function(data,t,n){var r=this.array,i=1*n*4;if(t)return r[i++]=0,r[i++]=0,r[i++]=0,void(r[i++]=0);var o=Object(v.floatColor)(data.color);r[i++]=data.x,r[i++]=data.y,r[i++]=data.size,r[i]=o}},{key:"render",value:function(t){var n=this.gl,r=this.program;n.useProgram(r),n.uniform1f(this.ratioLocation,1/Math.sqrt(t.ratio)),n.uniform1f(this.scaleLocation,t.scalingRatio),n.uniformMatrix3fv(this.matrixLocation,!1,t.matrix),n.drawArrays(n.POINTS,0,this.array.length/4)}}]),r}(d.AbstractNodeProgram)}}]);